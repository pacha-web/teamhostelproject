import 'dart:async';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:go_router/go_router.dart';
import 'dart:html' as html; // only used on web

// Firebase options (generated by FlutterFire CLI)
import 'firebase_options.dart';

// Screens
import 'screens/splash_screen.dart';
import 'screens/student/student_home.dart';
import 'screens/admin/admin_panel.dart';
import 'screens/admin/add_student.dart';
import 'screens/admin/requested_gate_pass.dart';
import 'screens/admin/student_list_page.dart';
import 'screens/auth/universal_signin.dart';
import 'screens/security/qr_scanner_page.dart';
import 'screens/resolve_role.dart';

/// ------------------ FCM / Local Notifications Setup ------------------ ///

final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

const AndroidNotificationChannel _channel = AndroidNotificationChannel(
  'high_importance_channel',
  'High Importance Notifications',
  description: 'This channel is used for important notifications.',
  importance: Importance.high,
);

Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  debugPrint(
      'Background message received: ${message.messageId}, data: ${message.data}');
}

/// Save token to Firestore for current user
Future<void> _saveFcmTokenForCurrentUser() async {
  final user = FirebaseAuth.instance.currentUser;
  if (user == null) return;

  try {
    final token = await FirebaseMessaging.instance.getToken(
      vapidKey: kIsWeb ? "YOUR_WEB_PUSH_VAPID_KEY" : null,
    );

    if (token != null && token.isNotEmpty) {
      await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .set({'fcmToken': token}, SetOptions(merge: true));
    }

    FirebaseMessaging.instance.onTokenRefresh.listen((newToken) async {
      if (newToken != null && newToken.isNotEmpty) {
        await FirebaseFirestore.instance
            .collection('users')
            .doc(user.uid)
            .set({'fcmToken': newToken}, SetOptions(merge: true));
      }
    });
  } catch (e) {
    debugPrint('Error saving FCM token: $e');
  }
}

/// Request notification permissions (iOS, Android 13+, Web)
Future<void> _requestNotificationPermissions() async {
  try {
    if (kIsWeb) {
      final permission = await html.Notification.requestPermission();
      debugPrint('Web notification permission: $permission');
    } else {
      final settings = await FirebaseMessaging.instance.requestPermission(
        alert: true,
        badge: true,
        sound: true,
      );
      debugPrint('Mobile notification permission: ${settings.authorizationStatus}');
    }
  } catch (e) {
    debugPrint('Error requesting notification permissions: $e');
  }
}

/// Setup foreground message handling and local notifications
void _setupFCMHandlers(GoRouter router) {
  FirebaseMessaging.onMessage.listen((RemoteMessage message) {
    debugPrint('Foreground message received: ${message.messageId}');
    final notification = message.notification;
    final android = message.notification?.android;

    if (kIsWeb) {
      // Web: simple alert for foreground messages
      html.window.alert(
        '${notification?.title ?? ''}\n${notification?.body ?? ''}',
      );
    } else if (notification != null && android != null) {
      flutterLocalNotificationsPlugin.show(
        notification.hashCode,
        notification.title,
        notification.body,
        NotificationDetails(
          android: AndroidNotificationDetails(
            _channel.id,
            _channel.name,
            channelDescription: _channel.description,
            importance: Importance.high,
            priority: Priority.high,
          ),
        ),
        payload: message.data.isNotEmpty ? message.data.toString() : null,
      );
    }
  });

  FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
    final data = message.data;
    if (data.containsKey('type')) {
      final type = data['type'];
      if (type == 'gatepass_request') {
        router.go('/requested-gate-pass');
      } else if (type == 'gatepass_status') {
        router.go('/student-home');
      }
    }
  });

  FirebaseMessaging.instance.getInitialMessage().then((message) {
    if (message != null) {
      debugPrint('App opened from terminated state by notification: ${message.data}');
    }
  });
}

/// ------------------ End FCM / Local Notifications Setup ------------------ ///

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  if (kIsWeb) {
    // Register service worker for web push notifications
    if (html.window.navigator.serviceWorker != null) {
      await html.window.navigator.serviceWorker!
          .register('firebase-messaging-sw.js');
      debugPrint('âœ… Service Worker registered for web notifications');
    }
  }

  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
  const iosInit = DarwinInitializationSettings();
  const initSettings = InitializationSettings(android: androidInit, iOS: iosInit);
  await flutterLocalNotificationsPlugin.initialize(initSettings,
      onDidReceiveNotificationResponse: (NotificationResponse response) {
    debugPrint('Local notification tapped. Payload: ${response.payload}');
  });

  await flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>()
      ?.createNotificationChannel(_channel);

  runApp(const HostelApp());
}

class HostelApp extends StatelessWidget {
  const HostelApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'Hostel Gate Pass',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        primarySwatch: Colors.blue,
        appBarTheme: const AppBarTheme(
          backgroundColor: Colors.blue,
          foregroundColor: Colors.white,
        ),
      ),
      routerConfig: _router,
    );
  }
}

/// Auth watcher to request permission, save token, and setup handlers
class _AuthWatcher extends StatefulWidget {
  final Widget child;
  const _AuthWatcher({required this.child, super.key});
  @override
  State<_AuthWatcher> createState() => _AuthWatcherState();
}

class _AuthWatcherState extends State<_AuthWatcher> {
  StreamSubscription<User?>? _authSub;

  @override
  void initState() {
    super.initState();

    _authSub = FirebaseAuth.instance.authStateChanges().listen((user) async {
      if (user != null) {
        await _requestNotificationPermissions();
        await _saveFcmTokenForCurrentUser();
        _setupFCMHandlers(_router);
      }
    });
  }

  @override
  void dispose() {
    _authSub?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}

/// ------------------ GoRouter Definition ------------------ ///
late final GoRouter _router = GoRouter(
  initialLocation: '/',
  refreshListenable:
      GoRouterRefreshStream(FirebaseAuth.instance.authStateChanges()),
  routes: <RouteBase>[
    GoRoute(path: '/', builder: (context, state) => const SplashScreen()),
    GoRoute(path: '/signin', builder: (context, state) => const UniversalSignIn()),
    GoRoute(path: '/resolve', builder: (context, state) => const ResolveRolePage()),
    GoRoute(path: '/admin', builder: (context, state) => const AdminPanel()),
    GoRoute(path: '/add-student', builder: (context, state) => AddStudentPage()),
    GoRoute(path: '/requested-gate-pass', builder: (context, state) => const RequestedGatePass()),
    GoRoute(path: '/qr-scanner', builder: (context, state) => const QRScannerPage()),
    GoRoute(
      path: '/student-home',
      builder: (context, state) {
        final extra = state.extra as Map<String, dynamic>? ?? {};
        return StudentHomeScreen(
          studentName: extra['studentName'] ?? 'Student',
          profileImageUrl: extra['profileImageUrl'] ?? '',
        );
      },
    ),
    GoRoute(path: '/student-list', builder: (context, state) => const StudentListPage()),
  ],
);

/// Helper to refresh GoRouter when auth state changes
class GoRouterRefreshStream extends ChangeNotifier {
  GoRouterRefreshStream(Stream<dynamic> stream) {
    _sub = stream.listen((_) => notifyListeners());
  }
  late final StreamSubscription<dynamic> _sub;
  @override
  void dispose() {
    _sub.cancel();
    super.dispose();
  }
}
